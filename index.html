
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
        <meta
            name="description"
            content="Documentation for the Kittn API"
        >
    <title>libggafx API Reference</title>

    <style media="screen">
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cpf {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s, .highlight .sa, .highlight .dl {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf, .highlight .fm {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv, .highlight .vm {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .nl {
  color: #f92672;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <style media="print">
      * {
        -webkit-transition:none!important;
        transition:none!important;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #586e75;
}
.highlight .err {
  color: #002b36;
  background-color: #dc322f;
}
.highlight .c, .highlight .ch, .highlight .cd, .highlight .cm, .highlight .cpf, .highlight .c1, .highlight .cs {
  color: #657b83;
}
.highlight .cp {
  color: #b58900;
}
.highlight .nt {
  color: #b58900;
}
.highlight .o, .highlight .ow {
  color: #93a1a1;
}
.highlight .p, .highlight .pi {
  color: #93a1a1;
}
.highlight .gi {
  color: #859900;
}
.highlight .gd {
  color: #dc322f;
}
.highlight .gh {
  color: #268bd2;
  background-color: #002b36;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #6c71c4;
}
.highlight .kc {
  color: #cb4b16;
}
.highlight .kt {
  color: #cb4b16;
}
.highlight .kd {
  color: #cb4b16;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .dl, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #859900;
}
.highlight .sa {
  color: #6c71c4;
}
.highlight .sr {
  color: #2aa198;
}
.highlight .si {
  color: #d33682;
}
.highlight .se {
  color: #d33682;
}
.highlight .nn {
  color: #b58900;
}
.highlight .nc {
  color: #b58900;
}
.highlight .no {
  color: #b58900;
}
.highlight .na {
  color: #268bd2;
}
.highlight .m, .highlight .mb, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mx {
  color: #859900;
}
.highlight .ss {
  color: #859900;
}
    </style>
    <link href="stylesheets/screen-c9d8fa83.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print-953e3353.css" rel="stylesheet" media="print" />
      <script src="javascripts/all-b12a2749.js"></script>

    <script>
      $(function() { setupCodeCopy(); });
    </script>
  </head>

  <body class="index" data-languages="[&quot;shell&quot;,&quot;ruby&quot;,&quot;python&quot;,&quot;javascript&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar-cad8cdcb.png" alt="" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo-1e815a84.png" class="logo" alt="" />
        <div class="lang-selector">
              <a href="#" data-language-name="shell">shell</a>
              <a href="#" data-language-name="ruby">ruby</a>
              <a href="#" data-language-name="python">python</a>
              <a href="#" data-language-name="javascript">javascript</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <ul id="toc" class="toc-list-h1">
          <li>
            <a href="#82fb364030" class="toc-h1 toc-link" data-title="簡介">簡介</a>
          </li>
          <li>
            <a href="#gba-graphics-system-specification" class="toc-h1 toc-link" data-title="GBA graphics system specification">GBA graphics system specification</a>
          </li>
          <li>
            <a href="#ppu-processing-flowchart" class="toc-h1 toc-link" data-title="PPU processing flowchart">PPU processing flowchart</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#character-mode-bg-mode-0-2" class="toc-h2 toc-link" data-title="Character Mode (BG Mode 0-2)">Character Mode (BG Mode 0-2)</a>
                  </li>
                  <li>
                    <a href="#screen-memory" class="toc-h2 toc-link" data-title="Screen memory">Screen memory</a>
                  </li>
                  <li>
                    <a href="#palette-memory" class="toc-h2 toc-link" data-title="Palette memory">Palette memory</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#errors" class="toc-h1 toc-link" data-title="Errors">Errors</a>
          </li>
      </ul>
        <ul class="toc-footer">
            <li><a href='#'>Sign Up for a Developer Key</a></li>
            <li><a href='https://github.com/slatedocs/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id='82fb364030'>簡介</h1>
<p>Libggafx是一個模擬Gameboy Advance(GBA) PPU的函式庫，此函式庫會依照系統當前的狀態繪製出相對應的畫面</p>
<h1 id='gba-graphics-system-specification'>GBA graphics system specification</h1>
<ul>
<li>GBA依靠一顆訂製的圖形核心Pixel Processing Unit(PPU)來處理以及繪製遊戲圖形，以下是其輸出規格:

<ul>
<li>240 x 160 LCD 屏幕</li>
<li>最大同時顯色數: 32768</li>
<li>支持數種圖形特效:

<ul>
<li><a href="#affine">旋轉/縮放</a></li>
<li><a href="#alpha-blending">半透明(α blending)</a></li>
<li><a href="#fade">淡入淺出(fade-in/out)</a></li>
<li><a href="#mosiac">馬賽克(mosiac)</a></li>
</ul></li>
<li>96KBytes VRAM + 1KBytes Palette + 1KBytes OAM</li>
</ul></li>
</ul>

<aside class="notice">
    有關memory layout，請參閱<a href="#vram-layout">VRAM layout</a>
</aside>
<h1 id='ppu-processing-flowchart'>PPU processing flowchart</h1>
<ul>
<li>擷取自 AGB Programming Manual Version 1.1 p15 CPU Block Diagram
<p align="center">
<img src="https://lh3.googleusercontent.com/fife/AAbDypC7XHXLnbAgRNjNl9T0HITXat5RNv7VoNs8C7kwUla4ffKY5Rw6YIRgN5Rc6HPFV8BqO9QjbY4EswrCwDjF7JUACxEGWsbs17ya5kwj7T86MsNU8l5U6_JHYRSNGFEdl1Xj--bplVy6UmxOV0aGYOVYaKzCPKhffUA2CDPnubDmMPOavWuyKSt9y5l1Z7IcrcVC7ryhU0_xkwcyU0Y8yDMrFY6YgmON9ja0bYwM50ntJAzBbI0vkOr-ITkd0CU_SuRgwRpNF-dIMz4ryOmZ99BB7KLqx9tHDAEC6MQuPLRY7RnC2mhZsV9JFzGCudBNC2egCBxranKz8pEHR_7Dd7pcEbmktrhP4v6AD0JD9o7Hidhm5eFDYqWCyGoxmpFz05QaEc0B7U96Q1FR8zNbrK2Z4e7H5NN1RoWYKzc3uTFJIDupwQC0cytVvM3Q1Z6C6QIUPT88cmREWywvWtXXsD2XW5M12jpLxTeJVLhJXOlyJUWHOJeXZjPcu87I7cdX5V_S_vTWipE4P5-lx_BLKgmsOhaJmvThu--ubeuor2mC2TsrU-K2NJb89FaSKccnMkxsEyM_sKSuw_FdTJz2_eYq9EjRFQp8nSldhMdDVHuHwXmHOVAIJ65KrjldMOguKRJxSXNDn1HZ29VCRnaw_QRs9ZfY3hm8FAD7UUzRntXoJxGqzmjcA_o2XYZMx1Ov8le6Q4FdD1xtGDiv1DJ_rf3D-LeGXvq6gltdw-JIqdQxB-4baScdz41QRNR5GskeYbc_FzyXy_AhnsxVBAbkSf2k5YDQL3ESR3-nCtYYzmpHTeLvOnhLE1slRh5lqL_UkXCiC7oMq230tYa-JZRr2TPKzDMATk3GU6srI7hNB1CrHe9F7pCURCXiT76bwsvEqKf-9Ydylo8FzvDw15LpTKLKx6OyOKDY1XxOhDQvrkPSFYN9eR2G2KjGW5poXcQTfEmznEudj4rrBJEuR17qSjzB11TRg_iygh_otA5OIxQANRXnB5L0iUC7-oAdZ24hch9_Ulmp2wzHB3aGNyQ_pgFN61dDfzn5m8BYMY25-oTotFZiy3l4FATOE8pp0J-8RdjngnRkjgX8TMxcvIu2W7VB86e8XjBX2wQSOdGugIPdtLGext73iuaEUJAbT4kQ01XWz2FKcTow-pJqpwLHWCshGBzj6JdJdFboOcqYdyskd7efyBdwfQKx0C3ERM6fZbna49XRQuMadU9EcqWAMLLdeKA2BiPH2keDXyWtJl4x5WqPOCGqviB_Ujs2_a4MhFa38rp1kcrLVDCPL13OZSZmvpAWYmn4E6Sq91sYQR4MOcuJgziC4L3Jv2gHKkW2tFl7aw-kJfIM9AJpMR9OS-ATdVfyLtIkVKWGVsOxbiaBNzxfOHxC7VVIDvNuDtzlCyvE9ZE9U6wrXwsToqEytEY0tznseugepUpIj8ud0rEl4YpUIXO9vGWbOkdMb4az0bW4chNFefalbNanQ94=w958-h911">
</p></li>
<li>不難看出每一幀遊戲畫面都是依照以下的處理流程在進行繪製:

<ol>
<li>繪製背景圖層</li>
<li>繪製Sprite(OBJ)</li>
<li>進行z index checking

<ul>
<li>就是依照前後順序來疊合圖層</li>
</ul></li>
<li>如果是Mode[0, 1, 2]則使用palette上色，反之為bitmap mode，跳過上色</li>
<li>特殊效果處理</li>
</ol></li>
<li>更準確地來說，每一幀顯示畫面都是逐行繪製的

<ul>
<li>有一些特殊效果必須依賴這個特性才能正確顯示，所以想要投機取巧的一次畫完整個畫面應該是<strong>不可行</strong></li>
<li>每一行(Row)繪製完畢後會觸發系統的H-Blank，每一幀繪製完畢後會觸發系統的V-Blank，詳情請參閱<a href="#PPU-interrupt-mechanism">PPU interrupt mechanism</a></li>
</ul></li>
<li>libggafx的做法是用一個drawing cursor，一路從[0, 0]繪製到[239, 0]，接著再換到[0, 1]~[239, 1]，最終整個幀的繪製會結束於[239, 159]

<ul>
<li>對於每一row，libggafx都會分別繪製出所有的BG row &amp; Sprite row, 再根據各圖層的z index做疊合，最後進行特效處理
# Background drawing</li>
</ul></li>
</ul>

<p>GBA在繪製Background(BG)圖層，一共有6種mode，mode [0, 1 ,2]為基於character的tile mode
mode [4 ,5, 6]則是直接繪製pixel的bitmap mode，以下會個別解釋</p>

<aside class="notice">
以下會使用Frame來描述模擬器最終輸出的畫面(240 * 160)，Screen則是指各background圖層所指定的screen memory

frame上面的每一個pixel都會依照特定規則對應到screen上的pixel
</aside>
<h2 id='character-mode-bg-mode-0-2'>Character Mode (BG Mode 0-2)</h2>
<p>Character Mode是統稱，泛指Mode 0, 1, 2這三種基於character顯示的繪製模式，這三種模式在使用上也有點差異，詳見下表</p>

<p align="center">
    <img src="https://lh3.googleusercontent.com/fife/AAbDypAFWtrthCQIW-q-AecbUAusMM85aCUOOHOnuvu71ZYulHxafE7PNcPu3swv5Tsh5JXgT115icBo9l7_XhA3SdHNTnb_e2clt7A-Ehxud4DFbPRGHB49A1Rhf7SwgS54c4-AB2qWPfLKJvpAxBA8vsGVg3jXQC4tLEg0KeqHsBhpOUYdy7PRY_55GxzeW5mG6PCgT3KUnSQT_lm1H08POmz-HTfZsZv3nHjdOmU5QXgHe3gQP8XuozXvvyOnVUybkDavP2M78-4xTlVoC55hm8odRvvzWXdT_PJT9gzcyWi-8jBOzOFgu0_3w64mFjqOd81kW5oyN-vaz9JxZbi1Y7SvK6rYhXIEJAEizNhS92ZIWScgn1EO5yqYDvogz62BO2BleRLQmJSTaBETkcOq6B-4HIntr8xTZ86-TlSWW_RB_vg39SiBqnGxZu3A-0ELF-x_iLfDLx8CXYOVKthjnt4MLlMKvx907GFj2jf0InkxkxhJ82aOM1X1JkKO2ZnSfRuF7_-LGYJHbPmpsxKC8h_T5up_ABCurAv5SW8fSW2QkeM9BZHsxJkUWZiUk1XtLZfaaLTVZi1d0dsb7TLfn6HjqP3FhGTuWjQDO4zjEWn_lGeLUuuTOQlB2oXYc2eVYUmJkhha3-ItYxOk6aeiEsH3YYhXYoLAWdB8lEU8J5fV-0uLOYQlbzKgySl6LzwJoadCkmMbu_g9Qh5HXCRDCY0rqu9hsaZaBaED_C7B1iew1Wjr7stfhwzeKo31LOdq9ON8ZVGH74ikw0h1F2tcUw8G1rCJ-K1R92ny2KOKtbFj-nnSPOpR3BP3AL0dV32Gp1LOoMp0d6-gzHtnDAdMDJVNk4o_OzoRUrjdL1G8gPYsd0XI6dR4_534l7E70sf7TCTmVAaYTtx-L9dS4ABBhUZWZKfBC64mMEa6dh75VSgk3q-X2S9JfSr0Hgzd9pUBpDSs2my5Yzjy30GXDU76LhCz2Z0fZvbw2UxS9s7H-1Ir0_jrcm2_VLA57AAuj1vyBaAT8uTswBpYkblmkbUcDorPiojHbA6ACZY-OmMgXLQrU9Z1r_IGsCqRSq6UlgFT3Hltv-k5p0TXlJ8wttPcVL5s74hFVBPMUWrjCvr2ibzjdKW1JT6qsWffNkqLIfeMemGIJUKfzDyT3TjvlYzudRlr8ntGjEqh2Zgqm-XcD0-xfN6NHrBC7MnVMZY85SqfxMnAbNAGYK9BYhojrxaGsAWKh4sGRXIKvgvmC7lG0pylFObXMpPnEUSCkKluQ4DZ7MmTT_Y3oXPTMtC2DQqFS62w5SZHdMySTKDTUpW40MqjkQf1dYuFMrIH_75ONoZrlkebLFbuSJQQ4YtJBkZ0paD-VJ6oAoB7F_ppEO0xhdlZt8_-zb4hCyRPCu8QMr7_LIMoGZY1lOV00c2JkD8WYt4rETgzZLD6DiwDMrSbOJcPZiC7ZVr-UmziRCXf0D79c6awtEdXLEtkAbzbdL8=w964-h958">
</p>

<aside class="notice">
Feature:
    <ol>
        <li>[BG圖層]水平/垂直捲動</li>
        <li>[character]水平/垂直翻轉</li>
        <li>[BG/Character]馬賽克效果</li>
        <li>[BG/Character]alpha blending</li>
        <li>[BG/Character]淡入淺出</li>
        <li>[BG/Character]z index</li>
    </ol>
</aside>
<h3 id='frame-cursor-to-screen-cursor-mapping'>Frame cursor to screen cursor mapping</h3>
<p>libggafx在每一幀計算中，會依照當前的background mode不同，選擇正確的方式來找到frame pixel對應到的screen pixel位置
- Text mode: 
<code>
screen_x := (frame_x + HOFS) % screen.w
screen_y := (frame_y + VOFS) % screen.h
</code>
- Rotate/Scale mode: 
基本上這裡的運算是一個仿射變換，規則如下所述
$$
    \begin{bmatrix}PA&amp;PB\PC&amp;PD\end{bmatrix} \times \begin{bmatrix}Frame_X\Frame_Y\end{bmatrix} + \begin{bmatrix}BG_X\BG_Y\end{bmatrix} = \begin{bmatrix}Screen_X\Screen_Y\end{bmatrix}
$$
但仔細梳理一下，可以把運算做一個簡化，得出以下結論
```
frame_x +1，screen_x的變動量為screen_dx1，則:
screen_dx1 = PA </p>

<p>frame_y +1，screen_x的變動量為screen_dx2，則:
screen_dx2 = PB</p>

<p>frame_x +1，screen_y的變動量為screen_dy1，則:
screen_dy1 = PC </p>

<p>frame_y +1，screen_y的變動量為screen_dy2，則:
screen_dy2 = PD</p>

<p>結論:
[screen_x, screen_y] = [PA*frame_x + PB*frame_y + BG_X, PC*frame_x + PD*frame_y + BG_Y]
由於是逐行渲染，所以我們只要從該row的第一個screen cursor開始，不停的把座標位置加上[PA, PC]就可以得出下一個pixel的screen cursor位置</p>

<p>換行也同理，下一行的screen cursor就會從[PB*frame_y, PD*frame_y]開始算
```</p>
<h3 id='use-screen-cursor-to-find-the-screen-data-address'>Use screen cursor to find the screen data address</h3>
<p>(here)</p>
<h3 id='drawing-step-of-character-mode-background'>Drawing step of character mode background</h3>
<ul>
<li>PPU在繪製每一個character mode background圖層時，會參考以下兩個記憶體區段:

<ul>
<li><a href="#Screen-memory">Screen memory</a>

<ul>
<li>用來描述Character如何在圖層中分布</li>
</ul></li>
<li><a href="#Character-memory">Character memory</a>

<ul>
<li>描述組成圖形的基本8 * 8圖塊(tile)之內容</li>
</ul></li>
</ul></li>
<li>libggafx會依照以下的步驟進行每一層的Background圖層繪製

<ol>
<li>在進行background繪製時，libggafx內部會有另外一個screen cursor，指向screen上的某一位置[screen_x, screen_y]</li>
<li>讀取Screen data，根據其標記的屬性解析character</li>
<li>(修改一下描述順序，還是不太順)</li>
<li>在實際繪製的過程中我們會有兩個cursor

<ul>
<li>Text mode: 

<ul>
<li>若當前的drawing cursor位於[60, 120], 且[HOFS, VOFS] = [10, 10],  則Screen cursor即為[60 + 10, 120 + 10] = [70, 130]</li>
<li>由上述流程可以得知Screen cursor有可能會超出Screen的範圍(常見於256 * 256的狀況)，因此我們必須要再做mod(eg. [cursor.x, cursor.y] = [cursor.x % SCREEN_W, cursor.y % SCREEN_H])</li>
<li>確定正確的screen cursor座標後，我們要再進一步將其轉換成正確的screen memory offset，才能存取正確的screen data

<ul>
<li>由於每一個character都是8 * 8，所以我們先將screen cursor都除8(&gt;&gt; 3)，計算出當前的screen cursor位於哪一個character中，我們將此xy稱為<strong>screen_data_cursor</strong></li>
<li>接下來根據當前的SCREEN_W計算出screen的每一row會有幾個character，我們稱它為<strong>charPerRow</strong>，算法就是SCREEN_W / 8</li>
<li>要計算出screen memory offset，公式為
&gt; (charPerRow * screen_data_cursor.y + screen_data_cursor.x) * 2</li>
<li>乘2是因為text mode的每一個screen data都是2 byte</li>
</ul></li>
<li>在計算完screen memory offset後，我們需要將此offset加到base address上才會是正確的screen data address

<ul>
<li>screen data在VRAM中以0x4000 byte為分割單位，因此想要計算base address必須先從BGCNT[08:12]讀取Screen Base Block，在乘上0x4000，最後加上VRAM base addr[0x0600&#39;0000]，就會是base address</li>
<li>雖然每一個Screen base block是0x4000bytes，但還是會有算上offset後，位置跑到另外一個block的狀況發生，此乃正常現象，切勿驚慌</li>
</ul></li>
</ul></li>
</ul></li>
</ol></li>
</ul>

<p>4. 確認當前的drawing cursor位於character的中的位置，圖取該位置的pixel data
    5. 將該palette index寫入BG row buffer，結束繪製流程
我們可以重點留意以下數點資訊:</p>

<ul>
<li>僅有Mode 1, 2可支援旋轉/縮放</li>
<li>各Mode所能夠顯示的Screen數量與尺寸並不相同(詳見<a href="#Screen-memory">Screen memory</a>)</li>
<li>調色盤的格式可分為16*16以及256*1(詳見<a href="#Palette-memory">Palette memory</a>)</li>
</ul>

<p>此模式會利用預先準備好的Character來組合出各BG圖層的內容，此模式的工作效率較bitmap模式來得高，因此大部分的商業遊戲都會使用此模式進行遊戲畫面繪製</p>
<h2 id='screen-memory'>Screen memory</h2>
<p>在 Character mode 下，每一個BG圖層要由那些character組成，character要在那裡出現都是由Screen memory決定</p>

<p>以最一般的情況[256 * 256]</p>
<h2 id='palette-memory'>Palette memory</h2>
<aside class="notice">
character我們可以把他理解成一個大小為8*8的小圖塊，遊戲程式會在需要的時候將這些character搬移進VRAM中進行繪製，詳細請參閱<a href="#Character-drawing">Character drawing</a>
</aside>
<h1 id='errors'>Errors</h1>
<aside class="notice">
This error section is stored in a separate file in <code>includes/_errors.md</code>. Slate allows you to optionally separate out your docs into many files...just save them to the <code>includes</code> folder and add them to the top of your <code>index.md</code>'s frontmatter. Files are included in the order listed.
</aside>

<p>The Kittn API uses the following error codes:</p>

<table><thead>
<tr>
<th>Error Code</th>
<th>Meaning</th>
</tr>
</thead><tbody>
<tr>
<td>400</td>
<td>Bad Request -- Your request is invalid.</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized -- Your API key is wrong.</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden -- The kitten requested is hidden for administrators only.</td>
</tr>
<tr>
<td>404</td>
<td>Not Found -- The specified kitten could not be found.</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed -- You tried to access a kitten with an invalid method.</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable -- You requested a format that isn&#39;t json.</td>
</tr>
<tr>
<td>410</td>
<td>Gone -- The kitten requested has been removed from our servers.</td>
</tr>
<tr>
<td>418</td>
<td>I&#39;m a teapot.</td>
</tr>
<tr>
<td>429</td>
<td>Too Many Requests -- You&#39;re requesting too many kittens! Slow down!</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error -- We had a problem with our server. Try again later.</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable -- We&#39;re temporarily offline for maintenance. Please try again later.</td>
</tr>
</tbody></table>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="shell">shell</a>
                <a href="#" data-language-name="ruby">ruby</a>
                <a href="#" data-language-name="python">python</a>
                <a href="#" data-language-name="javascript">javascript</a>
          </div>
      </div>
    </div>
  </body>
</html>
